# README

## Remove the redundant design in LiveVariableInBranch

## Implement the transfer function(refer to anders moller's lecture)

## Practice using BitVector in LLVM 10

## TODO: use map to store the state before and after the instruction

switch (approxMode){
            case MAY:
                instPreFactMap[inst] |= bv;
            case MUST:
                instPreFactMap[inst] &= bv;
        }

line: 3 {r z }
line: 4 {r x z }
line: 5 {r z }
line: 7 {r z }
line: 8 {r x y }
line: 9 {r z }
line: 11 {r z }
line: 15 {}

int foo1() {
	int x, y, z, r;
	r = rand();
	x = 5;
	y = x / 2;

	for (; r < 200; ++r) {
		if (r > 100 && r < 180) {
			z = x - 1;
	 	} else {
			z = y - 1;
		}
	}
	return z;
}

Instruction:
  store i32 %call, i32* %r, align 4, !dbg !20
z

Instruction:
  call void @llvm.dbg.declare(metadata i32* %x, metadata !11, metadata !DIExpression()), !dbg !12
z

Instruction:
  call void @llvm.dbg.declare(metadata i32* %y, metadata !13, metadata !DIExpression()), !dbg !14
z

Instruction:
  call void @llvm.dbg.declare(metadata i32* %z, metadata !15, metadata !DIExpression()), !dbg !16
z

Instruction:
  call void @llvm.dbg.declare(metadata i32* %r, metadata !17, metadata !DIExpression()), !dbg !18
z

Instruction:
  %call = call i32 (...) @rand(), !dbg !19
z

Instruction:
  store i32 5, i32* %x, align 4, !dbg !21
r z

Instruction:
  %0 = load i32, i32* %x, align 4, !dbg !22
r x z

Instruction:
  %div = sdiv i32 %0, 2, !dbg !23
r z

Instruction:
  store i32 %div, i32* %y, align 4, !dbg !24
r z

Instruction:
  br label %for.cond, !dbg !25
r z

Instruction:
  %1 = load i32, i32* %r, align 4, !dbg !26
r z

Instruction:
  %cmp = icmp slt i32 %1, 200, !dbg !29
z

Instruction:
  br i1 %cmp, label %for.body, label %for.end, !dbg !30
z

Instruction:
  %2 = load i32, i32* %r, align 4, !dbg !31
r y

Instruction:
  %cmp1 = icmp sgt i32 %2, 100, !dbg !34
r y

Instruction:
  br i1 %cmp1, label %land.lhs.true, label %if.else, !dbg !35
r y


36------------>35



Instruction:
  %3 = load i32, i32* %r, align 4, !dbg !36
r x y

Instruction:
  %cmp2 = icmp slt i32 %3, 180, !dbg !37
r x y

Instruction:
  br i1 %cmp2, label %if.then, label %if.else, !dbg !38
r x y

Instruction:
  %4 = load i32, i32* %x, align 4, !dbg !39
r x

Instruction:
  %sub = sub nsw i32 %4, 1, !dbg !41
r

Instruction:
  store i32 %sub, i32* %z, align 4, !dbg !42
r

Instruction:
  br label %if.end, !dbg !43
r z

Instruction:
  %5 = load i32, i32* %y, align 4, !dbg !44
r y

Instruction:
  %sub3 = sub nsw i32 %5, 1, !dbg !46
r

Instruction:
  store i32 %sub3, i32* %z, align 4, !dbg !47
r

Instruction:
  br label %if.end
r z

Instruction:
  br label %for.inc, !dbg !48
r z

Instruction:
  %6 = load i32, i32* %r, align 4, !dbg !49
r z

Instruction:
  %inc = add nsw i32 %6, 1, !dbg !49
z

Instruction:
  store i32 %inc, i32* %r, align 4, !dbg !49
z

Instruction:
  br label %for.cond, !dbg !50, !llvm.loop !51
r z

Instruction:
  %7 = load i32, i32* %z, align 4, !dbg !53
z

Instruction:
  ret i32 %7, !dbg !54